import pytest
import os
import pandas as pd
from src.generation.utils import get_kdid_for_name

###############################################################################
# 1) Pytest fixture that reads the CSV (e.g., "05_isikuaadress.csv")
###############################################################################

@pytest.fixture
def isikuaadress_df():
    """
    Reads "output/05_isikuaadress.csv", generated by the generate_isikuaadress function.
    We parse date columns like IAdrKehtibAlatesKpv, IAdrKehtibKuniKpv, etc.
    """
    path = os.path.join("output", "05_isikuaadress.csv")
    df = pd.read_csv(
        path,
        parse_dates=[
            "IAdrKehtibAlatesKpv","IAdrKehtibKuniKpv",
            "LoodiKpv","MuudetiKpv","KustutatiKpv"
        ],
        encoding='ISO-8859-1'
    )
    return df

@pytest.fixture
def kodifikaator_df():
    """
    Reads "data/kodifikaator.csv" if we want to validate whether 
    KdIDAadressiStaatus, KdIDAadressiLiik, etc. are valid.
    """
    path = os.path.join("data", "kodifikaator.csv")
    df = pd.read_csv(path, encoding='ISO-8859-1')
    return df

###############################################################################
# 2) Tests: Person's address logic
###############################################################################

def test_address_range_valid(isikuaadress_df):
    """
    Test1: IAdrKehtibAlatesKpv <= IAdrKehtibKuniKpv (if not None).
    The function in the code skips the period if st_>en_. 
    Theoretically, we shouldn't find such rows in the CSV.
    """
    bad = isikuaadress_df[
        isikuaadress_df["IAdrKehtibKuniKpv"].notnull() &
        (isikuaadress_df["IAdrKehtibAlatesKpv"] > isikuaadress_df["IAdrKehtibKuniKpv"])
    ]
    assert bad.empty, f"Leidsime ridu, kus algus>lÃµpp:\n{bad}"

def test_address_link_consistency(isikuaadress_df):
    """
    Test2: During linking (IAdrIDJargmine, DokIDLopuAlus),
    the function sets timeline[i]['DokIDLopuAlus'] = timeline[i+1]['DokIDAlus'].
    We check that this holds true in the CSV:
      - we filter rows where IAdrIDJargmine != null
      - then we join (merge) isikuaadress_df with itself on the next period's IAdrID
      - if parent.DokIDLopuAlus != child.DokIDAlus, we flag a mismatch
    """
    parent_df = isikuaadress_df[isikuaadress_df["IAdrIDJargmine"].notnull()].copy()
    # Merge to get the next period's DokIDAlus
    merged = parent_df.merge(
        isikuaadress_df[["IAdrID","DokIDAlus"]],
        left_on="IAdrIDJargmine",
        right_on="IAdrID",
        how="left",
        suffixes=("_parent", "_child")
    )
    mismatch = merged[
        (merged["DokIDLopuAlus"] != merged["DokIDAlus_child"]) &
        merged["IAdrIDJargmine"].notnull()
    ]
    assert mismatch.empty, (
        "Ootasime, et DokIDLopuAlus= DokIDAlus next periood, kuid leidsime:\n"
        f"{mismatch}"
    )

def test_address_end_is_kehtetu(isikuaadress_df, kodifikaator_df):
    """
    Test3: if IAdrKehtibKuniKpv != None, the function sets the status= KEHTETU,
    type=ENDINE ELUKOHT (see: if period_end is None => KEHTIV/ELUKOHT, else => KEHTETU/ENDINE ELUKOHT).
    """
    kd_kehtetu = get_kdid_for_name(kodifikaator_df, "KEHTETU")
    kd_endine = get_kdid_for_name(kodifikaator_df, "ENDINE ELUKOHT")
    if kd_kehtetu is None or kd_endine is None:
        pytest.skip("Puudub KEHTETU/ENDINE ELUKOHT kood.")

    ended = isikuaadress_df[isikuaadress_df["IAdrKehtibKuniKpv"].notnull()]
    mismatch = ended[
        (ended["KdIDAadressiStaatus"] != kd_kehtetu) |
        (ended["KdIDAadressiLiik"] != kd_endine)
    ][["IsID", "KdIDAadressiStaatus", "KdIDAadressiLiik", "IAdrKehtibKuniKpv"]]

    assert mismatch.empty, (
        "Suletud perioodil (KuniKpv != None) peaks staatus=KEHTETU, liik=ENDINE ELUKOHT.\n"
        f"{mismatch}"
    )

def test_address_open_is_kehtiv(isikuaadress_df, kodifikaator_df):
    """
    Test4: if IAdrKehtibKuniKpv = None, the function sets status= KEHTIV,
    type= ELUKOHT.
    """
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    kd_elukoht = get_kdid_for_name(kodifikaator_df, "ELUKOHT")
    if kd_kehtiv is None or kd_elukoht is None:
        pytest.skip("Puudub KEHTIV/ELUKOHT kood.")

    open_ = isikuaadress_df[isikuaadress_df["IAdrKehtibKuniKpv"].isnull()]
    mismatch = open_[
        (open_["KdIDAadressiStaatus"] != kd_kehtiv) |
        (open_["KdIDAadressiLiik"] != kd_elukoht)
    ]
    assert mismatch.empty, (
        "Avatud perioodil (KuniKpv=None) peaks staatus=KEHTIV, liik=ELUKOHT.\n"
        f"{mismatch}"
    )

def test_only_one_valid_residence_per_person(isikuaadress_df, kodifikaator_df):
    """
    Test10: Ensure that each person has at most one valid residence address
    (IAdrKehtibKuniKpv is null, KdIDAadressiStaatus=KEHTIV, KdIDAadressiLiik=ELUKOHT).
    """
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    kd_elukoht = get_kdid_for_name(kodifikaator_df, "ELUKOHT")
    if kd_kehtiv is None or kd_elukoht is None:
        pytest.skip("Missing KEHTIV/ELUKOHT code. Cannot perform test.")

    valid_residences = isikuaadress_df[
        isikuaadress_df["IAdrKehtibKuniKpv"].isnull() &
        (isikuaadress_df["KdIDAadressiStaatus"] == kd_kehtiv) &
        (isikuaadress_df["KdIDAadressiLiik"] == kd_elukoht)
    ]

    counts = valid_residences.groupby("IsID").size()
    multiple = counts[counts > 1]

    assert multiple.empty, (
        "Some persons have more than one valid residence address:\n"
        f"{multiple}"
    )

def test_valid_address_start_date_not_in_future(isikuaadress_df, kodifikaator_df):
    """
    KEHTIV-status residence entries in isikuaadress must not have IAdrKehtibAlatesKpv in the future.
    """
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    if kd_kehtiv is None:
        pytest.skip("KEHTIV status code not found.")

    # Ensure column is datetime
    isikuaadress_df["IAdrKehtibAlatesKpv"] = pd.to_datetime(
        isikuaadress_df["IAdrKehtibAlatesKpv"], errors="coerce"
    )

    now = pd.Timestamp.now()
    invalid = isikuaadress_df[
        (isikuaadress_df["KdIDAadressiStaatus"] == kd_kehtiv) &
        (isikuaadress_df["IAdrKehtibAlatesKpv"] > now)
    ]

    assert invalid.empty, (
        "Found KEHTIV residence entries with start date in the future:\n"
        f"{invalid[['IsID', 'IAdrID', 'IAdrKehtibAlatesKpv']]}"
    )



##############################################################################
# 2) Checking child period cloning
##############################################################################

def test_child_copy_of_parent(isikuaadress_df):
    """
    Test7: The child's period is cloned from the parent's period:
      timeline[i]['DokIDLopuAlus'] = timeline[i+1]['DokIDAlus'],
      the child's timeline has the same KdIDAadressiLiik, KdIDAadressiStaatus, AdrID, etc.
    In the CSV, it's tricky to test directly because there's no direct parent-child relationship column.
    If we had 'Vanuse staatus' = 'Laps' in the CSV, we could do partial checks.
    Here we skip or do minimal logic if there's no 'Vanuse staatus' column.
    """
    if "Vanuse staatus" not in isikuaadress_df.columns:
        pytest.skip("Puudub info, kes on laps. Ei saa lapse klooni testida.")

    # Simple check: a child presumably has some periods.
    # But we skip detailed checks if no parent-child link is available.


##############################################################################
# 3) MuudetiKpv / KustutatiKpv rules
##############################################################################

def test_modified_before_deleted(isikuaadress_df):
    """
    Test8: If KustutatiKpv is filled, it should be >= MuudetiKpv (if MuudetiKpv != None).
    """
    with_kust = isikuaadress_df[isikuaadress_df["KustutatiKpv"].notnull()].copy()
    invalid = with_kust[
        with_kust["MuudetiKpv"].notnull() &
        (with_kust["MuudetiKpv"] > with_kust["KustutatiKpv"])
    ]
    assert invalid.empty, (
        "Ridadel MuudetiKpv > KustutatiKpv, mis on loogikavastane.\n"
        f"{invalid}"
    )

def test_deleted_means_kehtetu(isikuaadress_df, kodifikaator_df):
    """
    Test9: There's a ~10% chance we set KustutatiKpv => sets kd_id_staatus= KEHTETU.
    So here we verify that if KustutatiKpv != null, KdIDAadressiStaatus= KEHTETU.
    """
    kd_kehtetu = get_kdid_for_name(kodifikaator_df, "KEHTETU")
    if kd_kehtetu is None:
        pytest.skip("Puudub KEHTETU kood, ei saa testida.")

    with_deleted = isikuaadress_df[isikuaadress_df["KustutatiKpv"].notnull()]
    mismatch = with_deleted[with_deleted["KdIDAadressiStaatus"] != kd_kehtetu]
    assert mismatch.empty, (
        f"Kustutatud periood eeldab staatus=KEHTETU. Leidsime:\n{mismatch}"
    )

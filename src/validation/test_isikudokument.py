import pytest
import os
import pandas as pd
from datetime import datetime
from src.generation.utils import get_kdid_for_name

@pytest.fixture
def isikudokument_df():
    """
    Reads the CSV file '08_isikudokument.csv', generated by generate_isikudokument().
    We parse LoodiKpv, MuudetiKpv, and KustutatiKpv as datetime objects.
    """
    path = os.path.join("output", "08_isikudokument.csv")
    df = pd.read_csv(
        path,
        parse_dates=["LoodiKpv","MuudetiKpv","KustutatiKpv"],
        encoding='ISO-8859-1',
        low_memory=False
    )
    return df

@pytest.fixture
def dokument_df():
    """
    Optionally reads '09_dokument.csv' (if it exists) 
    to verify DokID, AsIDValjaandjaAsutus, etc.
    """
    path = os.path.join("output", "09_dokument.csv")
    if not os.path.exists(path):
        pytest.skip("09_dokument.csv puudub, jätame vastavad testid vahele.")
    return pd.read_csv(
        path,
        parse_dates=[
            "DokValjaantudKpv","DokKehtivKuniKpv","DokKehtetuAlatesKpv",
            "LoodiKpv","MuudetiKpv","KustutatiKpv"
        ],
        encoding='ISO-8859-1'
        , low_memory=False
    )

@pytest.fixture
def isik_df():
    """
    If needed, reads '06_isik.csv' to check whether IsID is valid.
    """
    path = os.path.join("output", "06_isik.csv")
    if not os.path.exists(path):
        pytest.skip("06_isik.csv puudub, jätame vastavad testid vahele.")
    return pd.read_csv(path, encoding='ISO-8859-1')

@pytest.fixture
def kodifikaator_df():
    """
    Reads "data/kodifikaator.csv" if we want to validate whether 
    KdIDAadressiStaatus, KdIDAadressiLiik, etc. are valid.
    """
    path = os.path.join("data", "kodifikaator.csv")
    df = pd.read_csv(path, encoding='ISO-8859-1')
    return df

###############################################################################
# 1) Check the basic logic of IsikuDokument CSV
###############################################################################

def test_isikudokument_columns(isikudokument_df):
    """
    Test1: Verify that the necessary columns exist:
      IDokID, IsID, DokID, IDokIsikukood, IDokEesnimi, IDokPerenimi,
      KdIDIsikuRoll, LoodiKpv, MuudetiKpv, KustutatiKpv, etc.
    """
    required_cols = [
        "IDokID","IsID","DokID","IDokIsikukood",
        "IDokEesnimi","IDokPerenimi","IDokIsanimi",
        "IDokVanaEesnimi","IDokVanaPerenimi","IDokVanaIsikukood",
        "KdIDIsikuRoll","AsID","LoodiKpv","MuudetiKpv","KustutatiKpv"
    ]
    missing = [c for c in required_cols if c not in isikudokument_df.columns]
    assert not missing, f"Puuduvad veerud IsikuDokumendi failist: {missing}"

def test_isikudokument_primary_key(isikudokument_df):
    """
    Test2: IDokID must be unique and not null.
    """
    assert isikudokument_df["IDokID"].notnull().all(), "Leidsime tühje IDokID väärtusi."
    duplicates = isikudokument_df[isikudokument_df["IDokID"].duplicated()]
    assert duplicates.empty, f"Leidsime IDokID dublikaate:\n{duplicates}"

def test_isikudokument_isid_fk(isikudokument_df, isik_df):
    """
    Test3: isikudokument_df.IsID should find a match in isik_df.IsID (FK rule).
    """
    if isik_df is None:
        pytest.skip("Ei saanud isikutabelit, ei saa testida.")
    valid_isid = set(isik_df["IsID"].unique())
    used_isid = set(isikudokument_df["IsID"].unique())
    missing = [i for i in used_isid if i not in valid_isid]
    assert not missing, f"IsikuDokument.IsID viitab puuduvale IsID-le: {missing}"

def test_isikudokument_dokid_fk(isikudokument_df, dokument_df):
    """
    Test4: isikudokument_df.DokID should find a match in dokument_df.DokID (FK rule).
    """
    if dokument_df is None:
        pytest.skip("Ei saanud dokument tabelit, ei saa testida DokID FK.")
    valid_dokid = set(dokument_df["DokID"].unique())
    used_dokid = set(isikudokument_df["DokID"].unique())
    missing = [d for d in used_dokid if d not in valid_dokid]
    assert not missing, f"IsikuDokument.DokID viitab puuduvale DokID-le: {missing}"

def test_kehtiv_document_should_not_have_expiry_date(dokument_df, kodifikaator_df):
    """
    Test5: Documents with status 'KEHTIV' should not have DokKehtivKuniKpv filled (i.e. must be None).
    """
    # Get the KEHTIV status code from kodifikaator
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    if kd_kehtiv is None:
        pytest.skip("KEHTIV code not found in kodifikaator.")

    # Filter documents with KEHTIV status and non-null expiry date
    invalid = dokument_df[
        (dokument_df["KdIDDokumendiStaatus"] == kd_kehtiv) &
        dokument_df["DokKehtivKuniKpv"].notnull()
    ]

    assert invalid.empty, (
        "Documents with status KEHTIV should not have 'DokKehtivKuniKpv' set. Found:\n"
        f"{invalid[['DokID', 'DokKehtivKuniKpv', 'KdIDDokumendiStaatus']]}"
    )

def test_isikudokument_kehtiv_document_should_not_have_expiry(dokument_df, isikudokument_df, kodifikaator_df):
    """
    Test6: If a document referenced by isikudokument has status KEHTIV, it should not have DokKehtivKuniKpv filled.
    """
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    if kd_kehtiv is None:
        pytest.skip("KEHTIV status code not found in kodifikaator.")

    # Join isikudokument and dokument tables on DokID
    merged = isikudokument_df.merge(
        dokument_df[["DokID", "KdIDDokumendiStaatus", "DokKehtivKuniKpv"]],
        on="DokID",
        how="left"
    )

    invalid = merged[
        (merged["KdIDDokumendiStaatus"] == kd_kehtiv) &
        (merged["DokKehtivKuniKpv"].notnull())
    ]

    assert invalid.empty, (
        "Isikudokument viitab dokumendile, mis on KEHTIV, aga sellel on DokKehtivKuniKpv täidetud:\n"
        f"{invalid[['IDokID', 'DokID', 'DokKehtivKuniKpv', 'KdIDDokumendiStaatus']]}"
    )

def test_valid_document_start_date_not_in_future(dokument_df, kodifikaator_df):
    """
    Test7: KEHTIV-status documents must not have DokKehtivAlates in the future.
    """
    kd_kehtiv = get_kdid_for_name(kodifikaator_df, "KEHTIV")
    if kd_kehtiv is None:
        pytest.skip("KEHTIV status code not found.")

    now = datetime.now()

    # Ensure column is datetime
    dokument_df["DokKehtivAlates"] = pd.to_datetime(
        dokument_df["DokKehtivAlates"], errors="coerce"
    )

    invalid = dokument_df[
        (dokument_df["KdIDDokumendiStaatus"] == kd_kehtiv) &
        (dokument_df["DokKehtivAlates"] > now)
    ]

    assert invalid.empty, (
        "Found KEHTIV documents with start date in the future:\n"
        f"{invalid[['DokID', 'DokKehtivAlates']]}"
    )

###############################################################################
# 2) Old fields (IDokVanaEesnimi, IDokVanaPerenimi, IDokVanaIsikukood) test
###############################################################################

def test_isikudokument_old_fields(isikudokument_df):
    """
    Your code indicates ~5% chance to set 'Vana-' + first/last name, etc.
    We can't test the 5% ratio exactly (random), but we verify that if
    IDokVanaEesnimi is filled, it starts with 'Vana-', and so on.
    """
    old_ees = isikudokument_df["IDokVanaEesnimi"].dropna()
    for val in old_ees:
        assert val.startswith("Vana-"), (
            f"IDokVanaEesnimi peaks algama 'Vana-', kuid {val} ei alga."
        )
    old_perenimi = isikudokument_df["IDokVanaPerenimi"].dropna()
    for val in old_perenimi:
        assert val.startswith("Vana-"), (
            f"IDokVanaPerenimi peaks algama 'Vana-', kuid {val} ei alga."
        )
    old_isikukood = isikudokument_df["IDokVanaIsikukood"].dropna()
    for val in old_isikukood:
        assert val.startswith("OLD-"), (
            f"IDokVanaIsikukood peaks algama 'OLD-', kuid {val} ei alga."
        )

###############################################################################
# 3) Date checks for bridging: LoodiKpv, MuudetiKpv, KustutatiKpv
###############################################################################

def test_isikudokument_date_coherence(isikudokument_df):
    """
    In bridging_l code: LoodiKpv is in [doc_loodi..now], 50% updated, 5% deleted.
    We check that (MuudetiKpv <= KustutatiKpv) if both are not None.
    """
    invalid = isikudokument_df[
        isikudokument_df["KustutatiKpv"].notnull() &
        isikudokument_df["MuudetiKpv"].notnull() &
        (isikudokument_df["MuudetiKpv"] > isikudokument_df["KustutatiKpv"])
    ]
    assert invalid.empty, (
        f"Leidsime ridu, kus MuudetiKpv>KustutatiKpv:\n{invalid}"
    )

def test_isikudokument_deletion_vs_update(isikudokument_df):
    """
    The code: 5% chance bridging is 'deleted' => bridging_kustutati in [bridging_loodi..now],
    ensures MuudetiKpv >= KustutatiKpv => set to bridging_kustutati.
    So we check that if KustutatiKpv is filled, MuudetiKpv >= KustutatiKpv,
    meaning MuudetiKpv == KustutatiKpv.
    """
    with_deleted = isikudokument_df[isikudokument_df["KustutatiKpv"].notnull()]
    mismatch = with_deleted[
        with_deleted["MuudetiKpv"] != with_deleted["KustutatiKpv"]
    ]
    assert mismatch.empty, (
        "Kustutatud bridging kirjel eeldame MuudetiKpv=KustutatiKpv. "
        f"\n{mismatch}"
    )
